#include "uvcc/blv1.h"

#include <cstdint>
#include <iostream>
#include <string>
#include <vector>

static int fail(const std::string& msg) {
    std::cerr << "FAIL: " << msg << "\n";
    return 1;
}

static std::vector<std::uint8_t> expected_q4_bytes() {
    // Golden vector from research/PARALLEL.txt ยง2.4 (q_count=4 full payload hexdump).
    return {
        0x42, 0x4c, 0x56, 0x31, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x30, 0x00, 0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x04, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xbe, 0xad, 0xde, 0xef, 0xcd, 0xab, 0x89,
        0x67, 0x45, 0x23, 0x01,
    };
}

int main() {
    uvcc::BLV1Batch b;
    b.version = 1;
    b.flags = 0;

    uvcc::TLV tlv;
    tlv.type = 0x01;
    tlv.flags = 0x00;
    tlv.value = {
        // Value bytes are the 0x30 bytes after the TLV header in the golden vector.
        0x88, 0x77, 0x66, 0x55, 0x44, 0x33, 0x22, 0x11, 0x04, 0x00, 0x00, 0x00,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xef, 0xbe, 0xad, 0xde,
        0xef, 0xbe, 0xad, 0xde, 0xef, 0xcd, 0xab, 0x89, 0x67, 0x45, 0x23, 0x01,
    };
    b.tlvs.push_back(tlv);

    const auto got = uvcc::blv1_encode(b);
    const auto exp = expected_q4_bytes();
    if (got != exp) return fail("blv1_encode(q_count=4) mismatch");

    const auto parsed = uvcc::blv1_decode(got);
    if (parsed.version != 1 || parsed.flags != 0) return fail("blv1_decode header mismatch");
    if (parsed.tlvs.size() != 1) return fail("blv1_decode tlv_count mismatch");
    if (parsed.tlvs[0].type != 0x01 || parsed.tlvs[0].flags != 0x00) return fail("blv1_decode tlv hdr mismatch");
    if (parsed.tlvs[0].value != tlv.value) return fail("blv1_decode tlv value mismatch");
    return 0;
}


